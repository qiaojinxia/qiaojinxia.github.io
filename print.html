<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>leetcodebyrust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 草帽Boy的leetcode笔记</a></li><li class="chapter-item expanded "><a href="classify.html"><strong aria-hidden="true">2.</strong> 各题型分类整理</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> Leetcode 第9题 - 回文数(easy)</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> Leetcode 第1题 - 两数之和(easy)</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> Leetcode 第15题 - 三数之和(medium)</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">6.</strong> Leetcode 第7题 - 反转整数(medium)</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> Leetcode 第4题 - 寻找两个正序数组的中位数(hard)</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> Leetcode 第27题 - 移除元素(easy)</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> Leetcode 第27题 -  strStr() 函数(easy)</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> Leetcode 第19题 -  删除链表的倒数第N个节点</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> Leetcode 第26题 -  删除排序数组中的重复项</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">12.</strong> Leetcode 第108题 -  将有序数组转换为二叉搜索树</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">13.</strong> Leetcode 第32题 -  [最长有效括号]</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">14.</strong> Leetcode 第70题 -  [爬楼梯]</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">15.</strong> Leetcode 第120题- [三角形最小路径和]</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">16.</strong> Leetcode 第198题- [打家劫舍]</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">17.</strong> Leetcode 第155题 - [最小栈]</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">leetcodebyrust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#欢迎来到草帽boy的leetcode笔记" id="欢迎来到草帽boy的leetcode笔记">欢迎来到草帽Boy的Leetcode笔记</a></h1>
<img src="./image-20200623145600658.png" alt="image-20200623145600658" style="zoom:50%;" />
<h4><a class="header" href="#本站记录一些本人使用rust的刷题心得大爷如果您觉得对您有用--可以打赏哦" id="本站记录一些本人使用rust的刷题心得大爷如果您觉得对您有用--可以打赏哦">本站记录一些本人使用Rust的刷题心得,大爷如果您觉得对您有用 ↓ 可以打赏哦!</a></h4>
<p>本项目,目标 每天至少完成一道 leetcode,至少持续 一年,欢迎各位监督。</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
2020-06.25 -- 两数之和(easy)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-06.26 -- 三数之和(medium)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-06.27 -- 反转整数(easy)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-06.28 -- 寻找两个正序数组的中位数(hard)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-06-29 -- 移除元素(easy)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-06-30 -- 实现 strStr(表面上easy kmp算法)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-01 -- 删除链表的倒数第N个节点 (medium)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-02 -- 删除排序数组中的重复项 (easy)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-03 -- 将有序数组转换为二叉搜索 (easy)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-04 --  最长有效括号(hard)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-05 第70题 爬楼梯(easy)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-06 第198题 打家劫舍(easy)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-07 第120题 三角形最小路径和(medium)</li>
<li><input disabled="" type="checkbox" checked=""/>
2020-07-07 第155题 最小栈(easy)</li>
</ul>
<h1><a class="header" href="#分类整理" id="分类整理">分类整理</a></h1>
<p><a href="./classify.html">各题型整理</a></p>
<p>微信打赏 : </p>
<img src="./lbcf231650c77d851dd2be5403e9605a3-s-m213a3a4852edb6f5848e58fa3c667509.jpg" alt="lbcf231650c77d851dd2be5403e9605a3-s-m213a3a4852edb6f5848e58fa3c667509" style="zoom:33%;" />
<h3><a class="header" href="#微信号eismc_2-----" id="微信号eismc_2-----">微信号:eismc_2     👌</a></h3>
<blockquote>
<p>ps : 代码可以在线运行调试哦! </p>
</blockquote>
<h4><a class="header" href="#本网站托全管于-github" id="本网站托全管于-github">本网站托全管于 github</a></h4>
<h4><a class="header" href="#本网站使用mdbook生成所有源代码都是在a-hrefhttpsgithubcomrust-lang-nurserymdbookmozilla-public-license-v20a下发布的" id="本网站使用mdbook生成所有源代码都是在a-hrefhttpsgithubcomrust-lang-nurserymdbookmozilla-public-license-v20a下发布的">本网站使用mdBook生成,所有源代码,都是在<a href="https://github.com/rust-lang-nursery/mdBook/">Mozilla Public License v2.0</a>下发布的</a></h4>
<p><a href="https://github.com/qiaojinxia/qiaojinxia.github.io" data-title="" data-alt="GitHub followers" data-lightbox="roadtrip"><img src="https://img.shields.io/github/stars/snowdreams1006/snowdreams1006.github.io.svg?style=social" alt="GitHub followers" loading="lazy"></a></p>
<p><a href="https://github.com/facebook/react/blob/master/LICENSE"><a href="https://img.shields.io/badge/license-MIT-blue.svg" data-title="" data-alt="GitHub license" data-lightbox="roadtrip"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="GitHub license" loading="lazy"></a></a></p>
<h1><a class="header" href="#动态规划" id="动态规划">动态规划</a></h1>
<h4><a class="header" href="#动态规划的的四个解题步骤是" id="动态规划的的四个解题步骤是">动态规划的的四个解题步骤是：</a></h4>
<ul>
<li>定义子问题</li>
<li>写出子问题的递推关系</li>
<li>确定 DP 数组的计算顺序</li>
<li>空间优化（可选）</li>
</ul>
<h4><a class="header" href="#题目" id="题目">题目</a></h4>
<ul>
<li>
<p>入门题目:</p>
<ul>
<li><a href="./chapter_12.html">Leetcode 第70题 -  [爬楼梯]</a></li>
<li><a href="./chapter_13.html">Leetcode 第198题 -  [打家劫舍]</a></li>
<li><a href="./chapter_14.html"> Leetcode 第120题 - [三角形最小路径和]</a></li>
</ul>
</li>
<li>
<h2><a class="header" href="#进阶题目" id="进阶题目">进阶题目:</a></h2>
</li>
</ul>
<p>​	</p>
<h1><a class="header" href="#双指针" id="双指针">双指针</a></h1>
<ul>
<li>
<p>入门题目:</p>
</li>
<li>
<p>进阶题目</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#数据结构" id="数据结构">数据结构</a></h1>
<ul>
<li><a href="./chapter_15.html"> Leetcode 第155题 - [最小栈]</a></li>
</ul>
<h1><a class="header" href="#leetcode-第9题---回文数easy" id="leetcode-第9题---回文数easy">Leetcode 第9题 - 回文数(easy)</a></h1>
<p>题目:判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 121
输出: true
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
</code></pre>
<h2><a class="header" href="#编码实现思路" id="编码实现思路">编码实现思路</a></h2>
<p>Leetocde模板代码:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn is_palindrome(x: i32) -&gt; bool {
        

    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#实现思路" id="实现思路">实现思路</a></h3>
<p>这里我们先要熟悉,一个基本操作 一个数数 取个位只需要取余( % 10) </p>
<blockquote>
<p>101 % 10 = 1</p>
</blockquote>
<p>如果要把每一位 取出来 就需要 循环 /10  %10</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn takenum(x: i32) {
   let mut tmp = x;
    while tmp &gt;1 {
        print!(&quot;{} &quot;,tmp%10);
        tmp = tmp /10;
    }
    println!();

}

fn main() {
    takenum(543);
}
</code></pre></pre>
<p>leetcode给定的是 一个 i32数字,我们的思路是这样的 把 一个数字 比如 123 -&gt; 反转 成 321  如果判断反转后的数字,和原数字相等 那么 就是回文数字。</p>
<blockquote>
<p>example : 121 -&gt;</p>
<p>tmp1 = 取个位1 *  10 = 10</p>
<p>tmp1 += 取十位2 * 10  = (tmp1 + 2) * 10 = (10 +2) * 10 =120</p>
<p>tmp1 += 取百位1 * 10 =(tmp1 + 1) * 10 = (120 +2) * 10 =1210 </p>
<p>最后 tmp1 /10 = 121 </p>
</blockquote>
<h3><a class="header" href="#反转一个整数" id="反转一个整数">反转一个整数</a></h3>
<blockquote>
<p>example : 123 -&gt; 321 121-&gt;121 </p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust editable">pub fn reverse(x: i32) -&gt; i32{
    let mut tmp = x;
    let mut tmp1 = 0;
    while (tmp &gt;= 1) {
            // 123 第一次  temp1 30 tmp 12 -&gt; 第二次 320 1 -&gt; 第三次 3210 0.1 小于1 跳出循环 这样就完成了颠倒数字
        tmp1 = (tmp1 + tmp % 10 )* 10;
        tmp = tmp / 10;
    }
    tmp1 /10

}

fn main() {

    println!(&quot;{}&quot;,reverse(123));
}
</code></pre></pre>
<h3><a class="header" href="#回文数字完整代码" id="回文数字完整代码">回文数字完整代码</a></h3>
<p>有了上面的反转,只需要判断下 反转后的代码是否与原文一致即可,但是下面代码 还对 某些特殊的数字 比如负数、能被10整除的数、0~10的数字 直接做出判断、做了一些特殊条件的处理。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn is_palindrome(x: i32) -&gt; bool {
    // [0,10)之间的数 都为 true
    if(x &lt; 10 &amp;&amp; x &gt;=0){return true;}
    //如果 -开头的 和 100、1000 这样的直接排除
    if(x &lt; 0 || x % 10 ==0 ){ return false }
    let mut tmp = x;
    let mut tmp1 = 0;
    while (tmp &gt;= 1) {
        //将数字颠倒  123 先取出 3* 10 在把tmp更新成 12
       //这里加 if 是因为 如果是10位数 最后一次个位数再乘以10 -&gt; 11位数 就超出 i32 的最大值了 就会报错!
        if  tmp &lt; 10 { tmp1 = (tmp1 + tmp % 10 )}
        else{
            // 123 第一次  temp1 30 tmp 12 -&gt; 第二次 320 1 -&gt; 第三次 3210 0.1 小于1 跳出循环 这样就完成了颠倒数字
            tmp1 = (tmp1 + tmp % 10 )* 10;
        }
        tmp = tmp / 10;
    }
    //123 -&gt; 321 不相等 121 -&gt; 121 相等
    if tmp1 == x {
        return true;
    }
    return false;
}

//测试代码
fn main() {
    println!(&quot;{}&quot;,is_palindrome(123));
    println!(&quot;{}&quot;,is_palindrome(121));
    println!(&quot;{}&quot;,is_palindrome(1000000001));

}

</code></pre></pre>
<h3><a class="header" href="#提交结果" id="提交结果">提交结果：</a></h3>
<p><img src="./image-20200623143110412.png" alt="image-20200623143110412" /></p>
<p>ps:点击编辑器右上角 图标可运行代码哦!</p>
<img src="./image-20200623170053603.png" alt="image-20200623170053603" style="zoom:55%;" />
<h1><a class="header" href="#leetcode-第1题-两数之和easy" id="leetcode-第1题-两数之和easy">Leetcode 第1题 两数之和(easy)</a></h1>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
</blockquote>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]</p>
</blockquote>
<h2><a class="header" href="#方法一暴力解法" id="方法一暴力解法">方法(一)：暴力解法</a></h2>
<p>最简单的思路是 for 循环 两层 这样 所有可能的组合 。 </p>
<p>时间复杂度：$O_{(n^{2})}$</p>
<p>空间复杂度：$$O(1)$$</p>
<p>举个例子 [1,2,3] 就是 循环 $3^2$ 9次。</p>
<table><thead><tr><th>loop1/loop2</th><th>1</th><th>3</th><th>3</th></tr></thead><tbody>
<tr><td>1</td><td>[1,1]</td><td>[1,2]</td><td>[1,3]</td></tr>
<tr><td>2</td><td>[2,1]</td><td>[2,2]</td><td>[2,3]</td></tr>
<tr><td>3</td><td>[3,1]</td><td>[3,2]</td><td>[3,3]</td></tr>
</tbody></table>
<pre><pre class="playpen"><code class="language-rust editable">pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {
    let mut res =vec![];
    for i in  0..nums.len() {
        for j in  0..nums.len() {
            if i == j { continue;}
            if  nums[i] + nums[j] == target{
                res.push(i as i32);
                res.push(j as i32);
                return Vec;
            }
        }
    }
   res
}
</code></pre></pre>
<h1><a class="header" href="#hash表解法" id="hash表解法">Hash表解法</a></h1>
<p>从小学数学的角度 假设已知 矩阵 b= [ 1,2,7 ] 矩阵c =  [9,9,9]  定义 a + b = c ,那么按照矩阵的加法运算.</p>
<p>a  = c - b =  [9,9,9] -[1,2,7] = [8,7,2]  ，按照题目的定义  我们要求一个数 即满足 a + b = c, 同时 这个数 既属于矩阵a的子集 又属于 矩阵b的子集 ,那么 就可以表示为 $b{\bigcap}a $  那么把[1,2,7] $\bigcap$ [8,7,2] 那么 答案就是 7 和 2 但是 题目说一个元素不能被使用2次,那么如果是取 b = 2 那么 a = 7 如果 取 b = 7 那么 a = 2 按照for 循环顺序,2 在前 所以 会去到 b  =2 , a = 7。</p>
<p>综上分析：我们在每次循环 都把当前数的 另一半使得 a + b = c 的数算出来, 然后存起来,下次循环到下一个数的时候，去找下有没有记录,有的话就就直接返回结果。</p>
<p>那用什么存呢? 想想计算机的数据结构无非就那么几种,数组,栈,链表、HashMap 啊</p>
<ul>
<li>
<p>如果用数组,那么每次循环前就判断下,当前这个数是否在数组里被记录过了 可以用contains。,时间复杂度O(n!)、另外链表的复杂度也是一样的,用数组、链表 其实也就变成了暴力解法。</p>
</li>
<li>
<p>红黑树,时间复杂度(O(n$log_n$)) 红黑树相对快点,但还不是最高效的。</p>
</li>
<li>
<p>Hash表,hash表可以直接O(1)的复杂度,可以把 a 或者 b 当做key  value 随便放什么值, 只要能在表里找到的就是能解的。</p>
</li>
</ul>
<table><thead><tr><th align="left">c = 9</th><th>key</th><th>value,数组中的索引</th></tr></thead><tbody>
<tr><td align="left">模拟hashmap</td><td></td><td></td></tr>
<tr><td align="left">b_1 = 1  map.get(1) = null</td><td>8</td><td>0</td></tr>
<tr><td align="left">b_1 = 2  map.get(2) = null</td><td>7</td><td>1</td></tr>
<tr><td align="left">b_1 = 7  map.get(7) = 1,找到返回索引 0 和 2</td><td></td><td>2</td></tr>
</tbody></table>
<p>综上总结:使用 Hash 表的 复杂度为O(1),我们把 ,如果我们 给定 a = 1,c =8 那么 我们 只要在 hash 表的key里存  b = c - a = 7 那么  下次数组遍历到 7 然后去hash 表get(7) 有值,就说明 配对成功了 ，我们可以把hash表看作一个交友网站,你把你想要找的另一半 要求给记下了给到它,下次人家只要从这个等级的记录里面配对就好了。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;
impl Solution {
    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {
        let mut map: HashMap&lt;i32, i32&gt; = HashMap::new();
        for (i, v) in nums.iter().enumerate() {
            match map.get(v) {
               //匹配到 直接返回
                Some(&amp;index) =&gt; { return vec![index, i as i32] }
              //匹配不到 把当前数对应的解b = c -a  插入 value
                _ =&gt; { map.insert(target-v, i as i32); }
            }
        }
        vec![]
    }
}
</code></pre></pre>
<img src="./image-20200625133620313.png" alt="image-20200625133620313" style="zoom:50%;" />
<p>就暴力算法,在对比了 其他几门语言 发现性能还是比较出类拔萃的,基于同样逻辑用C实现的暴力算法 执行速度上 也比Rust满很多 不知道为什么 python 更是没法比相差 100多倍的,Go也是比较出色的能和,保Rust持同一个水平。</p>
<h1><a class="header" href="#leetcode-第15题---三数之和medium" id="leetcode-第15题---三数之和medium">Leetcode 第15题 - 三数之和(medium)</a></h1>
<blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<h2><a class="header" href="#示例" id="示例">示例</a></h2>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：
[
[-1, 0, 1],
[-1, -1, 2]
]</p>
</blockquote>
<h1><a class="header" href="#解题思路" id="解题思路">解题思路</a></h1>
<p>这道题目和求2树之和类似,多了一个数。那么最自然的想法 也是写算法中常用的的思维能不能把问题规模变小。</p>
<p>题目中 给出了注意事项 **答案中不可以包含重复的三元组。**那这是什么意思呢 ?</p>
<p>[-1, 0, 1, 2, -1, -4]  我们把解写成索引形式 -&gt; </p>
<blockquote>
<ol>
<li>
<p>[0, 1, 2] 对应 -1 + 0 + 1 =0</p>
</li>
<li>
<p>[0, 3, 4] 对应 -1 + 2 + -1 =0 </p>
</li>
<li>
<p>[1, 2, 4] 对应  0 + 1 + -1 = 0</p>
</li>
</ol>
</blockquote>
<p>但是你可以看到 其实 第1组 和 第3组只是数的位置不一样 里面的数字是一样的,题目就是想说明这一点,所以 我们在对得出结果后还要对相同的组进行去重。</p>
<p>a + b  + c = 0 是不是和 2数之和很相似,如果稍微改动下 变成 a + b = -c ,不就变成了2数之和了吗,那么 我们只要一层for 循环 来遍历 不同的c 就好了。 [-1, 0, 1, 2, -1, -4]  我们可以把 数组里面 的每一个数 当做 c 然后再去找 a 和 b。</p>
<h1><a class="header" href="#暴力解法" id="暴力解法">暴力解法</a></h1>
<p>时间复杂度： $$O_{(n^{3})}$$</p>
<p>空间复杂度：$$O(1)$$</p>
<h4><a class="header" href="#暴力解法-很简单-但是我们要注意的点" id="暴力解法-很简单-但是我们要注意的点">暴力解法 很简单 但是我们要注意的点</a></h4>
<ol>
<li>第一层循环i 从0 开始 第二层循环j 从i 开始 第三层循环m 从j 开始,为什么呢想像小时候的乘法口诀表 ?</li>
</ol>
<img src="./image-20200626103950720.png" alt="image-20200626103950720" style="zoom:30%;" />
<ol start="2">
<li>如果数组中有重复的元素 比如上面的 -1 ,我们需要去下重,否则 就会有2个同一答案  比如 [-1, 0, 1]   [0, 1, -1]</li>
</ol>
<p>你可以看到 我们一般 就只需要背一般剩余一半,只不过是镜像反转了 (i)1* (j)2 和 (i)2*(j)1是一样的。</p>
<p>下面 我们先不考虑第二点,把最简单的 一个暴力算法写出可运行的结果。</p>
<pre><pre class="playpen"><code class="language-rust editable">//----&gt;点击右上角 编辑调试代码
use std::collections::HashMap;
pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut res =vec![];
    for i in  0..nums.len() {
        for j in  i+1..nums.len() {
            for m in  j+1..nums.len() {
                if  nums[i] + nums[j] + nums[m] == 0{
                    let mut tmp =vec![];
                    tmp.push( nums[i]);
                    tmp.push(nums[j]);
                    tmp.push(nums[m]);
                    res.push(tmp);
                }
            }

        }

    }
    res
}
fn main() {
    let mut a1 =vec![-1, 0, 1, 2, -1, -4];
    println!(&quot;{:?}&quot;,three_sum(a1));
}
</code></pre></pre>
<p>最后的结果 输出 :</p>
<blockquote>
<p>[[-1, 0, 1], [-1, 2, -1], [0, 1, -1]]</p>
</blockquote>
<p>我们可以在 循环前先对数组排序,然后每层都去判断前一个数字是否和当前相同 相同 就跳过。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;
pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut nums = nums;
    nums.sort();
    let mut res =vec![];
    let mut flag = None;

    for i in  0..nums.len() {
    	//如果和前一个相同 就跳过
        if  { flag != None &amp;&amp; flag ==  Some(nums[i])}{continue;}
        flag = Some(nums[i]);
        let mut flag1 = None;
        for j in  i+1..nums.len() {
        	 //如果和前一个相同 就跳过
            if flag1 != None &amp;&amp;  flag1 ==  Some(nums[j]) { continue }
            flag1 = Some(nums[j]);
            let mut flag2 = None;
            for m in  j+1..nums.len() {
               //如果和前一个相同 就跳过
                if flag2 != None &amp;&amp;  flag2 ==  Some(nums[m]) { continue }
                flag2 = Some(nums[m]);
                if  nums[i] + nums[j] + nums[m] == 0{
                    let mut tmp =vec![];
                    tmp.push( nums[i]);
                    tmp.push(nums[j]);
                    tmp.push(nums[m]);
                    res.push(tmp);
                }
            }

        }

    }

    res
}
fn main() {

    let mut a1 =vec![0, 0, 0, 0];
    println!(&quot;{:?}&quot;,three_sum(a1));
      let mut a1 =vec![-1, 0, 1, 2, -1, -4];
    println!(&quot;{:?}&quot;,three_sum(a1));
   
}

</code></pre></pre>
<p>于是我们 很高兴的去leetcode 提交答案,但是果然 它 就超时了,毕竟现在 复杂度是$O^{3}$级别的。</p>
<h1><a class="header" href="#排序--hashmap" id="排序--hashmap">排序 + HashMap</a></h1>
<p>a + b + c = 0 我们使 b + c = d 那么 a  + d = 0 a = -d 能使 a 为 0 的 d 应该 只存在唯一一个。</p>
<p>但是  能使 b + c = d 的可能有很多解。</p>
<p>我们 循环是 先进行排序,把前一个和当前相同的 a 值过跳过, 因为 同一个 a 的出来的 是相同的 b 和 c 所以没有意义。 </p>
<p>接下来 我们  满足 b + c = d 的解可能是有 多组的,同时 我们还要注意 一点 b + c  和 c + b 也是同一组解,所以遇到这种情况 我们也要过滤掉。我们还需要注意 当 a 被用掉后 b 和 c 也不能用 a 的值 ,</p>
<p>因为本质上 a + b + c =0 可以设 a =b 这样 就可以变成 b + a  + c =0 这样 也是重复的解,只是位置换了。</p>
<p>我们 把 先前的 2数之和稍微改动下,就能使用了。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;
pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        let mut i = 0;
        let mut nums = nums;
        //排序
        nums.sort();
        let mut flag = None;
        let mut res:Vec&lt;Vec&lt;i32&gt;&gt; =vec![];
        while(i&lt;nums.len()){
            if flag != None &amp;&amp; Some(nums[i]) == flag{i+=1;continue;}
            flag = Some(nums[i]);
            let mut map: HashMap&lt;i32, usize&gt; = HashMap::new();
            let mut flag1:Option&lt;i32&gt; = None;
            for (j, v) in nums.iter().enumerate() {
                if j &lt; i +1 {continue;}
                if flag1 != None &amp;&amp; Some(*v) == flag1 {continue;}
                match map.get(v) {
                    //匹配到 直接返回
                    Some(&amp;index) =&gt; { res.push(vec![nums[i],nums[index], nums[j] ]);  flag1 = Some(*v); }
                    //匹配不到 把当前数对应的解b = c -a  插入 value
                    _ =&gt; { map.insert(-nums[i] - v, j ); }
                }
            }

            i+=1;
        }
        res
    }

fn main() {

    let mut a1 =vec![0, 0, 0, 0];
    println!(&quot;{:?}&quot;,three_sum(a1));
      let mut a1 =vec![-1, 0, 1, 2, -1, -4];
    println!(&quot;{:?}&quot;,three_sum(a1));
   
}
</code></pre></pre>
<img src="./image-20200626135325940.png" alt="image-20200626135325940" style="zoom:50%;" />
<p>最终 我们 靠自前面实现的2树相加 实现了,但是 现在时间复杂度 还是 接近$O^n$ ,效率还不是最高。</p>
<h1><a class="header" href="#排序--双指针" id="排序--双指针">排序 + 双指针</a></h1>
<p>前面 我们实现了 通过hashMap 实现了2数之和,但 执行时间 还是有点慢,下面 尝试用双指针来看看会不会有更好的性能。</p>
<p>首先明确的就是 双指针的思路 和 上面一种做法是一样的, a + b + c = 0 转换成 a + b = - c 然后定义2个指针,代表了 a 和 c 的取值,双指针的套路就是一般先要进行排序.然后 就是 就是一个while 左边小于右边就循环,</p>
<p>双指针 我们分别 指向一个左边的最小的数,和一个右边最大的数。</p>
<img src="./image-20200627102225337.png" alt="image-20200627102225337" style="zoom:50%;" />
<p>从图上我们可以观察处,</p>
<p>当a 指针 往 右移动  a + b 会变大</p>
<p>当 b 指针 往 左移  a + b 会变小</p>
<p>也就是说,如果 a + b &lt; -c 你就 移动 指针a,如果 a + b &gt; -c 你就移动 指针b,如果某一次移动 a 或 b后 正好等于了  - c,有点像 夹逼定理吧。</p>
<p>那么可以说 我们找到了那个数,并且 我们不能让指针 碰在一起,也就是 指针a 的索引 &gt; 指针b 的索引,那么 如果我们不设限制的话 当指针 a 超过指针b 后 其实相当于 变成了 a = b 位置颠倒了, 会出现   1 + 3 和 3 + 1 这样本质是一样。</p>
<p>另外要提的一点是,如果 排序后有重复的数字 比如上图的 -1 和 -1 这样 会出现重复的答案 我们需要作以下判断,分完了 开始编写代码把。</p>
<h4><a class="header" href="#我们先-搭了一个基本的框架" id="我们先-搭了一个基本的框架">我们先 搭了一个基本的框架</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut nums = nums;
    //作下 排序
    nums.sort();
    //定义 c
    for pointer_c in 0..nums.len(){
        //定义指针a 要比 c 大
        let mut pointer_a= pointer_c + 1;
        //定义指针 b
        let mut pointer_b =nums.len() -1;
        //左边的指针小于右边的指针
        while(pointer_a &lt; pointer_b ){

        }


    }
    vec![]
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#接下来我们填充下内容" id="接下来我们填充下内容">接下来我们填充下内容</a></h4>
<p>主要 判断下 a + b &gt; -c 和 a + b &lt; -c 或者 a + b = -c 的几种情况。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut nums = nums;
    //作下 排序
    nums.sort();
    let mut res =vec![];
    //定义 c
    for pointer_c in 0..nums.len(){
        //定义指针a 要比 c 大
        let mut pointer_a= pointer_c+1;
        //定义指针 b
        let mut pointer_b =nums.len() -1;
        //左边的指针小于右边的指针
        while(pointer_a &lt; pointer_b ){
            //如果 a + b &lt; -c 那么 往右移动a 指针 a + b 变大
            if nums[pointer_a] +  nums[pointer_b] &lt; -nums[pointer_c] {
                pointer_a += 1;
            //如果 a + b &gt; -c 那么 往左移动b 指针 a + b 变小
            }else if nums[pointer_a] +  nums[pointer_b] &gt;  -nums[pointer_c]{
                pointer_b -= 1;
             //如果 a + b = -c 找到了
            }else if nums[pointer_a] +  nums[pointer_b] ==  -nums[pointer_c]{
                res.push(vec![nums[pointer_a],nums[pointer_b],nums[pointer_c]]);
								
            }
        }


    }
    res

}
<span class="boring">}
</span></code></pre></pre>
<p>在 实现的过程中 我遗漏了一点分析,当 a + b = -c 是  能使 a + b = -c  的 a + b 的解可能是有多个的。当我们找到第一组后,该怎么 移动指针 继续寻找 后面可能的解呢? 无非 要么移动 a 要么移动 b 要么 a 和 b 都移动,仔细一想 a 唯一对应 一个 b 反过来 b 也是,也就是 a找到了它唯一的伴侣 b也找到了它唯一的伴侣,那么 他们就没必要在找小三了。那么 只要 a 和 b 的指针 + 1 即可。</p>
<img src="./image-20200627105930097.png" alt="image-20200627105930097" style="zoom:50%;" />
<p>我们 还需要 注意 一点 就是 c 最大 能取到 的位置,上图 是c 能取到 的最大位置了 如果再往右 a 和b 的指针就要重合 了 那就没有意义了。所以 我们判断下 c 最大的index 是 len() -2  。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut nums = nums;
    //作下 排序
    nums.sort();
    let mut res =vec![];
    //定义 c  
    for pointer_c in 0..nums.len() -2{ //c的最大界限 nums.len() -2 左闭右开
        //定义指针a 要比 c 大
        let mut pointer_a= pointer_c + 1;
        //定义指针 b
        let mut pointer_b =nums.len() -1;
        //左边的指针小于右边的指针
        while(pointer_a &lt; pointer_b ){
            //如果 a + b &lt; -c 那么 右移动a 指针 a + b 变大
            if nums[pointer_a] +  nums[pointer_b] &lt; -nums[pointer_c] {
                pointer_a += 1;
            //如果 a + b &gt; -c 那么 左移动b 指针 a + b 变小
            }else if nums[pointer_a] +  nums[pointer_b] &gt;  -nums[pointer_c]{
                pointer_b -= 1;
             //如果 a + b = -c 找到了
            }else if nums[pointer_a] +  nums[pointer_b] ==  -nums[pointer_c]{
                res.push(vec![nums[pointer_a],nums[pointer_b],nums[pointer_c]]);
                pointer_a += 1;
                pointer_b -= 1;

            }
        }


    }
    res

}


fn main() {

    let mut a1 =vec![-1, 0, 1, 2, -1, -4];
    println!(&quot;{:?}&quot;,three_sum(a1));
    // let mut a1 =vec![-1, 0, 1, 2, -1, -4];
    // println!(&quot;{:?}&quot;,three_sum(a1));
}

</code></pre></pre>
<p>运行下,上面代码来测试下吧!</p>
<p>当你运行上面代码,发现问题了吧, 有重复的 [0,1,-1] 上面我们提过的,向量元素 如果重复了 比如  上面数组 -1 -1 就重复了, 那就要跳过。</p>
<p>那么 我们 每次判断下,上一个元素是否相同,相同就跳过就好了 代码很简单,我们拿索引和上一个索引做下比较就好啦,但要注意 索引 0 要排除哦。</p>
<blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if pointer_c &gt;0 &amp;&amp; nums[pointer_c] == nums[pointer_c -1] { continue; }
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>到这里 我本以为 我的算法 就完美了 但是 。。。</p>
<p>没错 在leetcode 中 </p>
<blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut a1 =vec![-2,0,0,2,2];
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>我疏忽了 一点 就是 不只是 c 要判断 是否 相邻的有 重复跳过,  b 也需要 判断 是否相邻跳过。</p>
<p>否则的话 当我们 确定了 c = -2 那么 a 和 b 在 [0,0,2,2]里面选择  那么 就会产生 2对 一样的,其实了解了 这个原因 和上面一样 每次  都记录下上一组的值,做下 判断就好了。</p>
<img src="./image-20200627113954638.png" alt="image-20200627113954638" style="zoom:50%;" />
<p>我们  每次找到一组的时候 把结果保存下,再下一次找到的时候对比下 值是否相同即可。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>else if nums[pointer_a] +  nums[pointer_b] ==  -nums[pointer_c]{
    //比较上一组 的 a 是否和 这一次的相等 相等就跳过。
    if tag1 == Some(nums[pointer_a])  { pointer_a += 1;pointer_b -= 1; continue;}
    //每次保存下a的值
    tag1 = Some(nums[pointer_a]);
    ....

}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#完整代码" id="完整代码">完整代码</a></h1>
<pre><pre class="playpen"><code class="language-rust editable">pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
		//为了对付 leetcode 给的 比如像 [] [0] [1,2] 这样的没用数据
    if nums.len() &lt; 3 { return vec![];}
    let mut nums = nums;
    //作下 排序
    nums.sort();
    let mut res =vec![];
    //定义 c
    for pointer_c in 0..nums.len() -2{
        let mut tag1 = None;
        if pointer_c &gt;0 &amp;&amp; nums[pointer_c] == nums[pointer_c -1] { continue; }
        //定义指针a 要比 c 大
        let mut pointer_a= pointer_c + 1;
        //定义指针 b
        let mut pointer_b =nums.len() -1;
        //左边的指针小于右边的指针
        while(pointer_a &lt; pointer_b ){
            //如果 a + b &lt; -c 那么 右移动a 指针 a + b 变大
            if nums[pointer_a] +  nums[pointer_b] &lt; -nums[pointer_c] {
                pointer_a += 1;
            //如果 a + b &gt; -c 那么 左移动b 指针 a + b 变小
            }else if nums[pointer_a] +  nums[pointer_b] &gt;  -nums[pointer_c]{
                pointer_b -= 1;
             //如果 a + b = -c 找到了
            }else if nums[pointer_a] +  nums[pointer_b] ==  -nums[pointer_c]{
                if tag1 == Some(nums[pointer_a])  { pointer_a += 1;pointer_b -= 1; continue;}
                tag1 = Some(nums[pointer_a]);
                res.push(vec![nums[pointer_c],nums[pointer_a],nums[pointer_b]]);
                pointer_a += 1;
                pointer_b -= 1;

            }
        }


    }
    res

}
fn main() {
    let mut a1 =vec![-2,0,0,2,2];
    println!(&quot;{:?}&quot;,three_sum(a1));
    let mut a1 =vec![-1, 0, 1, 2, -1, -4];
    println!(&quot;{:?}&quot;,three_sum(a1));
    let mut a1 =vec![0, 0, 0, 0, 0, 0];
    println!(&quot;{:?}&quot;,three_sum(a1));
}

</code></pre></pre>
<img src="./image-20200627115118281.png" alt="image-20200627115118281" style="zoom:50%;" />
<p>第一次运行的时候 只超越了 30% 多,但 第二次运行后超越了 73% 真是搞不懂,我们算法 已经写的非常简洁了,如果还有什么地方可以优化 我感觉 那就只能在 排序那里优化了。</p>
<h1><a class="header" href="#leetcode-第7题---反转整数easy" id="leetcode-第7题---反转整数easy">Leetcode 第7题 - 反转整数(easy)</a></h1>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: 123
输出: 321</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: -123
输出: -321</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: 120
输出: 21</p>
</blockquote>
<h1><a class="header" href="#解题思路-1" id="解题思路-1">解题思路</a></h1>
<p>反转整数很简单 ,我们要一次拆解 各个位数 然后每次乘以 10 把上一次加上就好了,如果是负数 我们先把 符号 截取 反转后加上。</p>
<p>我们需要注意的是,32位的数的取值范围是  [−2^31, 2^31 − 1],如果反转后超出 这个值返回0 。</p>
<h4><a class="header" href="#example" id="example">example:</a></h4>
<p>给个  b = 1024   a = 0</p>
<p>第一次 a = (a +  b % 10)  * 10 = 4 *10 =40 然后更新下 b = 1024 /10  = 102</p>
<p>第二次 a = (a +  b % 10)  * 10 = (40 + 102 % 10) * 10 = 420  然后更新下 b = 102 /10  = 10</p>
<p>第三次 a = (a + b % 10) *10 = (420 + 10 % 10) * 10 = 4200  然后更新下 b = 10 /10  = 1</p>
<p>第四次 a = (a + b % 1) *10 =  (4200 + 1 % 10) * 10 = 4201 结束条件  b=1/10 =0.1  小于 1 条件结束</p>
<p>我们 要注意 在转换过程中,如果数字超出 范围就返回 0 ,为此 我们在 需要把数字转换成 i64 去判断下大小。</p>
<h2><a class="header" href="#全部代码" id="全部代码">全部代码</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">pub fn reverse(x: i32) -&gt; i32 {
    let mut tmp;
    if(x &lt; 0 ){
        tmp = -x;
    }else{
        tmp = x;
    }

    let mut tmp1 = 0;
    while (tmp &gt;= 1){
    		//转换成 i64 去判断是否溢出
        let mut tmpcalc = tmp1 as i64 + (tmp % 10) as i64 ;
        //这里当 分解到最后一位数的时候 就不要再成10了
        if tmp &gt;= 10 {
            tmpcalc*= 10;
        }
        //判断下 是否溢出
        if  tmpcalc &gt;  2147483648 ||  tmpcalc &lt;  -2147483648 { return 0;}
        tmp1 = tmpcalc as i32;
        tmp = tmp / 10;
    }
    //判断 x 是正数还是负数
    if x &lt;0{
        -tmp1
    }else{
        tmp1
    }
}

fn main() {
    println!(&quot;{}&quot;,reverse(102));
 		println!(&quot;{}&quot;,reverse(9080980));
 		println!(&quot;{}&quot;,reverse(90801290));
}
</code></pre></pre>
<img src="./image-20200627230138093.png" alt="image-20200627230138093" style="zoom:50%;" /><h1><a class="header" href="#leetcode-第4题---寻找两个正序数组的中位数hard" id="leetcode-第4题---寻找两个正序数组的中位数hard">Leetcode 第4题 - 寻找两个正序数组的中位数(hard)</a></h1>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>nums1 = [1, 3]
nums2 = [2]</p>
<p>则中位数是 2.0</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>nums1 = [1, 2]
nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
</blockquote>
<h1><a class="header" href="#解题思路-2" id="解题思路-2">解题思路</a></h1>
<p>最简单的方法 就是先合并 ,然后找到 中位数取出。</p>
<p>这里的知识点是小学数学我们学过的 取一组数的中位数,如果是 奇数个 假设数组长度 为 m ,那么 就是 <strong>ceil</strong>(m / 2)  ceil 是向上取整 比如 arr[<strong>ceil</strong>(9/2)] = arr[5] ,如果是偶数 那么 就是 取第<strong>ceil</strong>(m/2) 和 第<strong>ceil</strong>(m /2 + 1) 相加 </p>
<p>比如 arr[ ceil(10 /2 )] +arr[(ceil(10 /2) + 1)] =arr[5] + arr[6] 。</p>
<p>那么 我们需要做的 就是 把2个组数 在合并后每个数对应合并后的索引给找出来,这样 通过计算出来的 中位数的索引就可以确定 中位数了。</p>
<h1><a class="header" href="#双指针归并" id="双指针归并">双指针归并</a></h1>
<p>时间复杂度：O (m+ n) </p>
<p>空间复杂度：O (1)</p>
<p>中位数的计算,如果数组是 奇数个 直接取 中间的数    [ 1,2 ,3] -&gt; 2</p>
<p>如果数组是偶数个 取中间的 2个数相加除以 2  [1,2,3,4] -&gt; 2 + 3 / 2 =1.5</p>
<img src="./image-20200628123321636.png" alt="image-20200628123321636" style="zoom:50%;" />
<p>那么 由于数组原先就是有序的,我们 可以使用归并 定义2根指针 然后依次 比大小,然后不停的往后取。</p>
<img src="./image-20200628152315427.png" alt="image-20200628152315427" style="zoom:50%;" />
<pre><pre class="playpen"><code class="language-rust editable">pub fn find_median_sorted_arrays(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;) -&gt; f64 {
    let mut pointer_a = 0;
    let mut pointer_b = 0;
    loop {
        // 这个判断取的是公共长度的 部分 a 如果 长度为 5 b如果长度为 4 那么 这个判断里面 是 前 4个数归并
        if  pointer_a &gt; nums1.len() ||  pointer_b &gt; nums2.len()  {
            if nums1[pointer_a] &lt; nums2[pointer_b]   { //如果 指针a的值 &lt;  指针b的值 指针 a 往后移动一个位置
                println!(&quot;{}&quot;,nums1[pointer_a]);
                pointer_a +=1;
            }else if nums1[pointer_a] &gt; nums2[pointer_b]{  //如果 指针a的值 &gt;  指针b的值 指针 b 往后移动一个位置
                println!(&quot;{}&quot;,nums2[pointer_b]);
                pointer_b +=1;
            }else if nums1[pointer_a] == nums2[pointer_b]{//如果两个数 相等 2根指针 都往后移动1个位置
                println!(&quot;{}&quot;,nums1[pointer_b]);
                pointer_a +=1;
                pointer_b +=1;
            }
        }else if pointer_a &lt; nums1.len(){ //当 b指针的 长度 耗尽 了 我们只需要移动 a 指针就好了
            println!(&quot;{}&quot;,nums1[pointer_a]);
            pointer_a +=1;
        }else if pointer_b &lt; nums2.len(){ // 当 a指针的 长度耗尽了 ,接下来 我们只需要移动b 指针了
            println!(&quot;{}&quot;,nums2[pointer_b]);
            pointer_b +=1;
        }else{
            //上述条件都不满足,跳出循环
            break;
        }

    }
    1  as f64
}

fn main() {
    let mut a1 =vec![1,3,5,12,16];
    let mut a2 =vec![2,4,6,7,9];
    find_median_sorted_arrays(a1,a2);

}
</code></pre></pre>
<p>上面的 代码 我们久通过指针 指向了 2个数组,然后比较大小 然后移动指针,代码 比较简单 就是 定义 双指针 比大小 然后 移动指针。 要注意的是 由于2个数组长度不一样,当一个数组长度到头了,那么就移动剩下的数组指针到结束为止。</p>
<p>上面其实就实现了 将 2个有序数组进行归并的过程,实际上我们 没有定义一个数组 来存放 归并好的值,因为不需要这么做 我们直接通过 2根指针的 位置相加 计算出 每个数在 归并后数组的索引,如果 等于2个数组合并后中位数的索引 那么就找到了这个值。</p>
<p>但我们在编码的过程中,我们计算中位数索引的值需要注意,一点：</p>
<ol>
<li>我们对给定的2个数组长度相加是奇数和 偶数 做一下判断,如果是奇数 直接取  最中间的一个数,如果是 偶数要取到 中间的 2个数相加 再 除以 2。</li>
</ol>
<pre><pre class="playpen"><code class="language-rust editable">pub fn find_median_sorted_arrays(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;) -&gt; f64 {
		// 这个判断 是为了 处理一些 比如 [] ,[1] 这样糟糕的数据,偷懒 就直接在这处理掉吧!
    if (nums1.len() ==1 &amp;&amp; nums2.len() == 0) {
        return  nums1[0] as f64;
    }
    if(nums1.len() ==0 &amp;&amp; nums2.len() == 1) {
        return  nums2[0] as f64;
    }
    let mut pointer_a = 0;
    let mut pointer_b = 0;
    //flag 用于记录最后一次移动的 是 pointer_a 或者 是 pointer_b 或者都移动了
    let mut flag = 0;
    let mut lastnum =0;
    loop {
        // 这个判断取的是公共长度的 部分 a 如果 长度为 5 b如果长度为 4 那么 这个判断里面 是 前 4个数归并
        if  pointer_a &lt; nums1.len() &amp;&amp;  pointer_b &lt; nums2.len()  {
            if nums1[pointer_a] &lt; nums2[pointer_b]   { //如果 指针a的值 &lt;  指针b的值 指针 a 往后移动一个位置
                flag = 0;
            }else if nums1[pointer_a] &gt; nums2[pointer_b]{  //如果 指针a的值 &gt;  指针b的值 指针 b 往后移动一个位
                flag = 1;
            }else if nums1[pointer_a] == nums2[pointer_b]{//如果两个数 相等 2根指针 都往后移动1个位置
                flag = 2;
            }
        }else if pointer_a &lt; nums1.len(){ //当 b指针的 长度 耗尽 了 我们只需要移动 a 指针就好了
            flag = 0;
        }else if pointer_b &lt; nums2.len(){ // 当 a指针的 长度耗尽了 ,接下来 我们只需要移动b 指针了
            flag = 1;
        }else{
            //上述条件都不满足,跳出循环
            break;
        }
        //上面的所有代码 主要负责 循环移动a b 的指针,直到数组的末尾,需要 注意的 是 数组 总是有长有短 如果一边的指针 移动到末尾了 剩下的 全部移动 另一边的指针


        //如果 指针 指向了 中位数
        if  ((nums1.len() + nums2.len() -2 ) / 2) + 1 == pointer_a + pointer_b {
            //如果 数组1 + 数组2 是奇数个
            if  (nums1.len() + nums2.len()) % 2  != 0  {
                //处理 指针 a 移动了的情况
                if flag == 0{
                    return nums1[pointer_a] as f64;
                }else {
                    //如果指针 b 或者 2个指针都移动 的 情况
                    return nums2[pointer_b] as f64;
                }

            }else{//如果 数组1 + 数组2 偶数个

                //如果 是 偶数个 我们 需要 记录上一个数 和当前的 数相加 / 2
                if flag == 0{
                    return (nums1[pointer_a] as f64 +  lastnum as f64) / 2.00;
                }else {
                    return (nums2[pointer_b] as f64 +  lastnum as f64) / 2.00;
                }
            }
         //处理 pointer_a 和 【pointer_b 相等 都往后 移动 2步,那么 pointer_a + pointer_b == 数组1长度 + 数组2长度 -2 (从0索引开始 所以 -1 -1 = -2) /2 + 1
        }else if (nums1.len() + nums2.len() -2 ) / 2 + 1 &lt; pointer_a + pointer_b {
            break;
        }else{ //如果 不是中位数
            if flag ==0{
                lastnum =  nums1[pointer_a];
                //指针 a 往后移动一步
                pointer_a += 1;
            }else if flag ==1{
                lastnum =  nums2[pointer_b];
                //指针 b 往后移动一步
                pointer_b += 1;
            }else{
                lastnum =  nums1[pointer_a];
                //指针 a b 分别往后移动一步
                pointer_a += 1;
                pointer_b += 1;
            }

        }



    }
   return lastnum as f64;
}

fn main() {

    let mut a1 =vec![1,2];
    let mut a2 =vec![3,4];
    println!(&quot;{}&quot;,find_median_sorted_arrays(a1,a2));

}

</code></pre></pre>
<img src="./image-20200628175204548.png" alt="image-20200628175204548" style="zoom:50%;" />
<p>第一次 执行用了 8ms,后面执行 就变成 4ms了,不知道什么原因。</p>
<h1><a class="header" href="#二分法" id="二分法">二分法</a></h1>
<p>在 上面一种方法中,我们定义了 2根指针 从头开始 取计算 中位数对应的数,但实际上 我们可以 直接 用 二分法 每次折半 来缩减 查找的 范围。</p>
<p>假设 给定 2个数组 ,长度 分别为 6 和 5.</p>
<img src="./image-20200629142923958.png" alt="image-20200629142923958" style="zoom:50%;" />
<p>让我们 思考一个问题,什么是中位数,假定 我们 在 数组a 和数组b 中找到一个中位数,那么 不考虑 偶数个 中位数 就是 前边 和 后边的长度是一样的。</p>
<p>假设 数组 a 的长度为 m,数组b的长度 为 n </p>
<p>那么 中位数的位置 就是 (m + n + 1) / 2, 那么 意思是 我们只需要找到 一个数,它前面有  (m + n + 1) / 2 -1 个数那么 它不就</p>
<p>是中位数了吗。</p>
<h4><a class="header" href="#如上图如果我们假设-7-是中位数那么-怎么石锤-这个证明呢" id="如上图如果我们假设-7-是中位数那么-怎么石锤-这个证明呢">如上图,如果我们假设 7 是中位数,那么 怎么石锤 这个证明呢?</a></h4>
<p>只要证明 小于等于 7的 数是否有  (m + n + 1) / 2 -1 个不就好了吗 ?</p>
<h4><a class="header" href="#那问题进一步的-变成-怎么-计算-7--的数的个数呢" id="那问题进一步的-变成-怎么-计算-7--的数的个数呢">那问题进一步的 变成 怎么 计算 &lt;=7  的数的个数呢?</a></h4>
<p>那么 首先 数组 a 中 7的索引是 1 那么 我们就说 数组a 中小于等于7的 有一个数,在数组a中找比起小的很容易.</p>
<h4><a class="header" href="#那么-问题又变成了-怎么在-数组b-中找-7-的数的个数呢" id="那么-问题又变成了-怎么在-数组b-中找-7-的数的个数呢">那么 问题又变成了 怎么在 数组b 中找 &lt;=7 的数的个数呢?</a></h4>
<p>那么 逐个搜索不就好了吗,但是 有没有更好的方法呢? 既然给定的 数组b 是有序的那我们 就可以考虑 使用更高效的 搜索方法,对于有序的数组 抖索效率 最高的当然是属 二分搜索啦。</p>
<h1><a class="header" href="#" id=""></a></h1>
<p>那么 我们可以肉眼看到 数组 b 中,&lt;=7 的只有 1个 那么 加上 数组a 中的 一个 总共 就是 2个数, 12 / 2 -1 = 5 很明显,不符合 。</p>
<p>那么 我们使上帝视角 稍微观察下 就知道 中位数是13 是中位数,</p>
<p>那么 我们还是 证明下吧 13 的 index  = 2, 数组 a 中 &lt;= 13 的数 有 3 个,那么 3 + 2 = 5,  前面正好有  (m + n + 1) / 2 -1 </p>
<p>个 数那么 它的确是中位数。</p>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<p>根据上面的 证明 我们可以得出:</p>
<p>我们 可以先随机定义一根指针a,指向某个数,然后在另一个数组也定义一根指针b,</p>
<p>然后 我们假设 指针a 为 中位数 然后去指针 b 找 小于等于 a指针的个数,使用二分查找，每次 筛选掉一半,</p>
<p>然后再判定下 指针 a 是否有前 (m + n + 1) / 2 -1 个数 。</p>
<p>如果 a 前面的数 &gt; (m + n + 1) / 2 -1  说明  我们 要把 a 指针 往前 移动 </p>
<p>如果 a 前面的数 &lt;  (m + n + 1) / 2 -1  说明  我们 要把 a 指针 往后 移动</p>
<p>a指针 我们也每次移动 剩余范围的一半,采取这样的二分法。</p>
<p>这里我们 还要注意 如果 a 数组 里面找不到中位数,那么 我们就需要 直接在 b数组里面找中位数。</p>
<p>另外要注意的是 我们 希望是 在数组 a 里面找到 中位数,那么 要求 数组a的长度 &gt;= 数组b 的长度,所以我们 在一开始判断下谁的长度长 就是数组a 最下数组交换。</p>
<p>用这种方法,要处理很多 边界条件,太烦了 写了 70% 放弃。 </p>
<h2><a class="header" href="#找第-k-个数" id="找第-k-个数">找第 k 个数</a></h2>
<p>条件 给定数组 a 长度为 m,数组b 长度 为 n</p>
<p>那么 数组 a 和数组 b 的中位数 为 (m + n  + 1) /  2  为什么 + 1 呢?  主要是向上取整floor。如果不加 1 那么就是向下取整。 Floor(1.x)  =2  , ceil(1.x) = 1。</p>
<h3><a class="header" href="#二分法介绍" id="二分法介绍">二分法介绍</a></h3>
<p>如果给定一个 从小到大的数组,那么怎么快速查找一个数,一般使用二分法。二分法 是不断缩小搜索范围的一种方法。 </p>
<p>第一次 搜索范围一半 (m + n  + 1) /  2 一半分为 左边一半 和 右边一半</p>
<p><img src="./image-20200630154101244.png" alt="image-20200630154101244" /></p>
<p>二分法 是 每次都除以 2 这样 然后 收敛在 0点, 5 -&gt; 2 -&gt; 1  -&gt; 0。</p>
<p>我们 如果从给定的数组m 中去取第k个数,那么 它的前 面的 k -1 个数必然是小于等于 第k个数的。</p>
<p>那么 我们如果在 第二数组也找到第 k_ 个数,也是同样的结果,那么当我们 把第 数组 a 的 第k 个数和数组 b 的第k个数作比较,那么 必然有一方 大于或等于 另一方, 假设 数组 a 的 k为k_1 数组b 的 k为 k_2,假设 k_1 &gt;= k_2,那么 我们可以得出  2k -1 个数 不等于 第 2k 个数.</p>
<p><img src="./image-20200630160248239.png" alt="image-20200630160248239" /></p>
<p>那么 就排除前 2k -1 个数 了, 如果 k_1 要想成为 第 2k 个数,要满足 条件  k_2 的 第 k_2 + 1个数 &gt; 第 k_1个数,</p>
<p>否则的话 第 k 个数。如上图 假设 47 为 第 2k个数,他前面有 2k -1个数比它小。</p>
<img src="./image-20200630160935344.png" alt="image-20200630160935344" style="zoom:50%;" />
<p>如上图 我们可以看到,当数组 b 中 第 k + 1 个数 比 47 小了 那么 k就会变成 第 k + 1 个了,就好像 有人问你 跑过了 倒数第二名 你是第几名一样,  由于 43 比 47小所以 就替换了 47的位置 此时 43 变成了 第 k 位数。</p>
<h1><a class="header" href="#代码实战" id="代码实战">代码实战</a></h1>
<p>光说不练假把式,我们 可以用上面的思维 边完成代码 边继续推理,能边学习边及时得到反馈 也能让你更有兴趣对问题更加深入的研究。</p>
<h1><a class="header" href="#1-首先-我们-要定义-2k-是多少-我们-一般-把-2k-取为-中位数-的位置" id="1-首先-我们-要定义-2k-是多少-我们-一般-把-2k-取为-中位数-的位置">1. 首先 我们 要定义 2k 是多少, 我们 一般 把 2k 取为 中位数 的位置?</a></h1>
<p>假设 2个数组 m 长为 3 n长为 2 ,按照中位数的计算 应该取 (3 + 2 + 1)  / 2  = 3</p>
<p>那么 我们可以在 m 里 取 2,那在 n里取到 3 -2 = 1(注意实际索引 从 0开始 要 -1 但是为了方便了解这里 使用从1开始)</p>
<p>但是 如果 m 是个只有为 1的数组 那怎么办呢? 所以 我们在 取值的时候可以采用 将中位数 3/2 = 1 然后我们再判断下,如果 数组索引 比 1大 k_m取 1 比1小 k_m 取数组的长度。</p>
<p>然后k_n +  k_m  =3 , k_n取剩下部分。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub  fn find_median_sorted_arrays(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;) -&gt; f64{
  let mut nums1 = nums1;
    let mut nums2 = nums2;
    if nums1.len() &gt; nums2.len(){
        let tmp = nums1;
        nums1 = nums2;
        nums2 = tmp;
    }
    let k_2 = (nums1.len() + nums2.len() + 1) / 2 -1;
    //k 为小的数
    let mut k_m = nums1.len() -1;

    let mut k_n = 0;
    let k = k_2 / 2 ;

    if k_m &lt; k{
        k_n = k_2 - k_m -1;
    }else{
        k_m = k;
        k_n = k_2 - k -1 ;
    }

    println!(&quot;{},{}&quot;,pointer_a +1,pointer_b +1);
 		

}
fn main() {
    let m = vec![7,12,21,43,56,78];
    let n = vec![3,16,47,73,63];
    find_median_sorted_arrays(m,n);
}
</code></pre></pre>
<p>上面代码  k_2 变量名 就是 2k 个数的索引 也就是中位数索引,由于变量起名规则,下文 我们一致 用第K_2 个数 来替代 第2k 个数</p>
<h1><a class="header" href="#2如何找到中位数" id="2如何找到中位数">2.如何找到中位数?</a></h1>
<p>有了上面的划分 我们 就要来证明,如何找到中位数的位置呢.</p>
<p>我们知道 数组是从大到小有序的,并且上面的算法 把数组 划分成了这样</p>
<img src="./image-20200702113003988.png" alt="image-20200702113003988" style="zoom:50%;" />
<p>那么 我们首先尝试去 比较 k_m 和 k_n 的大小 谁大 我就认为 设就是暂时的第k_2个数,</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//谁大 谁就是 k_2 个数
if  nums1[pointer_a] &gt; nums2[pointer_b]{
    println!(&quot;{} &quot;,nums1[pointer_a]);
}else{
    println!(&quot;{} &quot;,nums2[pointer_b]);
}
<span class="boring">}
</span></code></pre></pre>
<p>那么 有了k_2 个数,我们 就要到中位数了吗? 其实还有挺长的路要走。</p>
<img src="./image-20200702113956361.png" alt="image-20200702113956361" style="zoom:50%;" />
<p>现在 呢 47是 第 k_2个数,但是 因为它前面有 k_2 - 1个数,那么想要维持住这种关系,那么 我们就要保证 </p>
<p>k_m  和 k_n   后面的数全部 要 大于 47, 由于 已知 是给定数组是升序排列的,就有 k_n + 1  &gt; k_n</p>
<p>那么 k_m 后面的数,就决定这 k_n 是不是 第 k_2 个数的关键。</p>
<p>此时 就会有两种情况：</p>
<ol>
<li>k_m + 1 &lt;  k_n 如果是 这种情况,那么 k_m + 1 将会插到 k_n 前面,使得 k_n 变成第 k_2 + 1 个数,而 k_m + 1变 成 第 k_2 个数。又 由于 k_m + 1 &lt; k_m + 2 那么,k_m + 1 前面不可能再插入其他数了,所以k_m + 1 就变成了k_2。 当然 在实际编码过程中,我们还要注意 k_m + 1 是否存在。</li>
<li>k_m + 1 &gt;= k_n 这种情况,k_m + 1 不能插入到k_n 前面所以不会影响 k_n ,所以不需要做什么.</li>
</ol>
<p>那么 分别讨论了上面2中问题,是不是就能 覆盖了所有问题了呢?</p>
<p>第一种情况 我们 还需要小心一点,如下图:</p>
<img src="./image-20200702120139880.png" alt="image-20200702120139880" style="zoom:50%;" />
<p>如果 k_m + 1 比 k_n小 故而插入到k_n前面 那么 k_m + 1 就一定 是紧挨着 47的吗?如果 k_m + 1 比前面的 某 1个数还小呢?</p>
<p><img src="./image-20200702123241629.png" alt="image-20200702123241629" /></p>
<p>上图,我们可以看到  第 k_2 个数,因为另一组比它更小的数的插入,而导致 第k_2个数位置发生变化。</p>
<p>要想稳定得到 第k_2个数,那么 我们要 另一组数组的 第k_m + 1个数要大于等于 第 k_2个数,这也是最重要的条件</p>
<p>如果小于的话 我们就需要把 k_n 也就是 现在的 第 k_2 个数 往左移动一格,并且 把 k_m 往右移动 这样 就还是能维持 k_m + k_n = k_2。</p>
<h1><a class="header" href="#例子" id="例子">例子</a></h1>
<img src="./image-20200703113526696.png" alt="image-20200703113526696" style="zoom:50%;" />
<p>我们可以划分为,红线以左指针区域 和 红线的以右指针右边区域,</p>
<p>当我们 求 中位数</p>
<p>如果是 偶数 就是 (max{指针区域} + min{指针右边区域})  /2</p>
<p>如果是 奇数时 max{指针区域} 。</p>
<p>为什么呢 ,因为我们定义了 我们的2个指针中永远有一个 是指向第k_2个数,另一个指向k_2 -1,此时我们假设 k_2 是中位数,那么 k_2 -1 &lt; k_,那么 求 max 就可以找到了。</p>
<p>如果是 奇数情况 我们只要找指针 直接求max 返回就可以。</p>
<p>如果是偶数的情况,那么 给定数组是有序的,假设 k_2 后面那个数 叫 k_2 + 1 那么 k_2 + 2 &gt; k_2 + 1 &gt; k_2,所以 min{ k_2 + 2 , k_2 + 1} 就可以得到 k_2 + 1了。</p>
<p>所以 偶数个 计算中位数就是 (max{指针区域} + min{指针右边区域})  /2</p>
<p>上面我们提到 我们定义了 2根指针指向了,k_m 和k_n 永远有一根是中位数。那么怎么找到 中位数呢?</p>
<p>我们只需要 保证 指针区域 的值 都小于 指针右边区域 其实就可以了. </p>
<p>如果不小于 我们就 一个往左移动指针,另一个往右移动指针,直到找到那么个区域,由于同时移动 一个 + 1 一个 减 1 那么 还是能保持 k_m + k_n = 2k.</p>
<p>但是我们 还要处理,边界的情况,</p>
<img src="./image-20200703115558576.png" alt="image-20200703115558576" style="zoom:50%;" />
<img src="./image-20200703115636449.png" alt="image-20200703115636449" style="zoom:50%;" />
<p>为了 处理 边界情况 我们 添加了 一些 不影响,中位数的数字 就是一些比较大的数字 和一些 比较小的数字</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>std::i32::MIN
std::i32::MAX
<span class="boring">}
</span></code></pre></pre>
<p>然后 就算 是边界,如上图 (max{-∞,7} + min{∞,9})  / 2= (7 + 9) / 2 也可以很好的计算了是不是。</p>
<p>为什么  下面那个数组 没有-∞ 实际上 按照我们的思路,一般不会出现  到边界 这种情况,除非什么空数组啊 什么的,但我们 对一些 比较麻烦的情况直接 偷懒 特殊处理。</p>
<h1><a class="header" href="#完整代码-1" id="完整代码-1">完整代码:</a></h1>
<pre><pre class="playpen"><code class="language-rust editable">pub  fn find_median_sorted_arrays(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;) -&gt; f64{
		//偷懒 处理 都是 1个的情况
    let iseve = (nums1.len() + nums2.len()) % 2 == 0;
    let mut nums1 = nums1;
    let mut nums2 = nums2;
    if nums1.len() &gt; nums2.len(){
        let tmp = nums1;
        nums1 = nums2;
        nums2 = tmp;
    }
    // 偷懒 解决数组有长度 一个数组 没长度
    if nums1.len() == 0  {
        if iseve {
            return  (nums2[(nums2.len())/2 -1] as f64 + nums2[(nums2.len() + 1)/2 ] as f64 )/ 2.00;
        }else{
            return nums2[(nums2.len() + 1)/2 -1] as f64
        }
    }

    let k_2 = (nums1.len() + nums2.len() + 1) / 2 -1;
    //k 为小的数
    let mut k_m = nums1.len() -1;

    let mut k_n = 0;
    let k = k_2 / 2 ;

    if nums1.len() + nums2.len() != 2 {
        if k_m &lt; k{
            k_n = k_2 - k_m -1;
        }else{
            k_m = k;
            k_n = k_2 - k -1 ;
        }
    }
    //交换数组 
    if nums1[k_m] &lt; nums2[k_n] {
        let tmp = nums1;
        nums1 = nums2;
        nums2 = tmp;

        let tmp = k_n;
        k_n = k_m;
        k_m = tmp;

    }
    //这里 push 几个值 是为了 处理边界的情况
    nums1.insert(0,std::i32::MIN);
    nums2.push(std::i32::MAX);
    nums1.push(std::i32::MAX);
    k_m +=1;

    //以下是 核心代码 上面预处理 没什么技术含量
    while k_n + 1 &lt; nums2.len() -1 &amp;&amp; nums1[k_m] &gt; nums2[k_n + 1]{
        if k_m == 0 {
            k_n +=1;
        }else{
            k_m -= 1;
            k_n +=1;
        }
    }
    if iseve {
        return (max(nums1[k_m],nums2[k_n]) as f64 +min(nums1[k_m +1],nums2[k_n +1]) as f64 )/ 2.00;
    }else{
        return max(nums1[k_m],nums2[k_n]) as f64;
    }
    -1.0

}
fn main() {

    let m = vec! [1,2] ;
    let n = vec! [3,4] ;
    println!(&quot;{}&quot;,find_median_sorted_arrays(m,n));
}
</code></pre></pre>
<img src="./image-20200702225920240.png" alt="image-20200702225920240" style="zoom:50%;" /><h1><a class="header" href="#leetcode-第27题---移除元素easy" id="leetcode-第27题---移除元素easy">Leetcode 第27题 - 移除元素(easy)</a></h1>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素</p>
</blockquote>
<h1><a class="header" href="#解题思路-3" id="解题思路-3">解题思路</a></h1>
<p>这里 其实很简单 我们 判断元素 是否为 要删除的元素 ,再使用rust 的remove 就好了,但是这里要注意 如果 我们通过索引取访问 到数组,那么当你remove 完了 后 数组里面 元素数 就少了 一个 下一次循环 就要减1, 那么 我们 每次 remove 后都需要计数 一下,然后 把 index 减去 这个计数 得出来的是 我们 删除后下一个元素的位置。</p>
<p>比如 [3,2,2,3] 我们要删除 2</p>
<p>如果 我们第一次去访问 index  = 0   访问到 3</p>
<p>第二次访问 index =1 访问到 2 是目标值 remove </p>
<p>当我们 第三次要访问 的时候 index = 2 但是 由素组被更新过了 变成了  [3,2,3] 访问 2 就直接变成了 3 了 跳过了 2 </p>
<p>所以 当我们 定义 一个 计数器 每当 remove 时 count+ 1 ,  每次访问的索引变成  index - count  这样 第三次访问变成了  1 这样 就解决了 这个问题.</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn remove_element(nums: &amp;mut Vec&lt;i32&gt;, val: i32) -&gt; i32 {
    let mut count:i32 = 0;
    for i in  0..nums.len(){
        if nums[i - count as usize] == val {
            nums.remove(i - count as usize);
            count +=1;
        }
    }
    nums.len() as i32
}
fn main() {

    let mut a1 =vec![3];
    let mut a2 =vec![3,2,2,3];
    println!(&quot;{}&quot;,remove_element(a2.as_mut(), 2));
    println!(&quot;{:?}&quot;,a2);
}

</code></pre></pre>
<img src="./image-20200629231857041.png" alt="image-20200629231857041" style="zoom:50%;" /><h1><a class="header" href="#leetcode-第27题----strstr-函数easy" id="leetcode-第27题----strstr-函数easy">Leetcode 第27题 -  strStr() 函数(easy)</a></h1>
<p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1</p>
</blockquote>
<h1><a class="header" href="#解题思路-4" id="解题思路-4">解题思路</a></h1>
<p>这题可以使用 暴力解法,2层循环 一层 指向 一个字符 内层去逐一 的匹配 字符串。</p>
<p>时间复杂度 是$ O(n^2)$</p>
<p>空间复杂度 $O(1)$</p>
<p>我们 想要尝试另一种做法,KMP算法。</p>
<p>时间复杂度 $O(N)$</p>
<p>空间复杂度 $O(M)$</p>
<h1><a class="header" href="#kmp算法" id="kmp算法">KMP算法</a></h1>
<p>kmp 算法 代码 非常简洁,紧凑但是 要理解起来还是有一定难度的。</p>
<p>kmp算法分为2步</p>
<ol>
<li>
<p>首先要构建 一个 next数组。</p>
</li>
<li>
<p>根据 next 数组直接匹配。</p>
</li>
</ol>
<p>首先 讲这个算法 之前 要明白 普通的双指针为什么 不可以匹配。</p>
<img src="./image-20200701182051646.png" alt="image-20200701182051646" style="zoom:50%;" />
<p>我们 可以看到 如果定义 2个指针(索引),从0 开始 指向 2个 数组,不相等 i就往后移,当相等 时 i和 j 都往后移</p>
<p>直到 i 和 j 指向的值不同 那么 就匹配结束。这种思维 是很普遍的 看起来很美好。</p>
<p>如上的数组 如果这么找 的话 , 当  i =  4 处 结束匹配 把 j 重置为 0,i 往后 开始下一轮匹配,这样很明显 后边还剩下 </p>
<p>ba 匹配不到 bcba,但是事实上 如果我们忽略掉 i = 1 处的匹配,从 i = 3 处匹配 完全就能匹配的到。我们为了便于讨论 把这个问题先起个名字 叫做 &quot;模式重复错误&quot;.</p>
<p>因为 第一次 的匹配导致后面不能完全匹配到字符, 首先 我们思考下 匹配的基本条件至少是开头要一样吧, 那么 也就是说 匹配的字符串 有一个特点，那就是 有和 开头那个字符 一样重复的 字符。</p>
<p>打个比方   abc 我们 可以把 </p>
<p>所有的子集 称为 {a,b,c,ab,bc,abc}  a模式 b模式 c模式 以此类推。</p>
<p>我们 把 所有 a 开头的 起个昵称 称为 开机模式群 {abcx}</p>
<p>我们 判定 某个字符都是从首字母开始的 也就是说 只要是 &quot;开机模式群&quot; 那么 我们就可以记一次 匹配字符串。</p>
<p>在 abc 中 开机模式群 只有一种组合 ,所以我们只需要 一次判断 。</p>
<p>但如果改成 aba 呢  里面 有2个 a 就有可能 {abax,ax} 就变成了 2种 组合,那么 就要 两次 匹配。</p>
<p>但是当我们 处在 一次匹配模式中,没法中途退出 就会出现 上面的 &quot;模式重复错误&quot; 问题。</p>
<p>那么 解决这个问题,的关键 是 如果我们知道 匹配字符串 包含 几种 &quot;开机模式群&quot; 的组合,那么 我们匹配错误的时候解出 一次匹配模式 然后切换到 另一种 &quot;开机模式群&quot; 状态 就可以 解决这个问题。</p>
<p>那怎么 切换呢,其实 {ax} 是 {abax}的子集,它们 之间 索引相差 值就好了,PMT表其实 就是计算 每个状态 切换 索引之间切相差的值。</p>
<p>而 next 表就是类似这样一个东西 ,让你从 &quot;开机模式群&quot;一种状态 切换到另一种 &quot;开机模式群&quot; 状态.</p>
<img src="./image-20200701185444874.png" alt="image-20200701185444874" style="zoom:50%;" />
<img src="./image-20200701185613169.png" alt="image-20200701185613169" style="zoom:50%;" />
<p>参考资料：https://www.bilibili.com/video/BV1Ys411d7yh?t=710</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::borrow::Borrow;
pub fn get_next(needle: &amp;String) -&gt; Vec&lt;i32&gt; {
    let mut tmpvec = Vec::with_capacity(needle.len());
    tmpvec.push(0);
    let mut j = 0;
    let mut i = 1;
    for _ in 1..needle.len() {
        if needle.as_bytes()[i] != needle.as_bytes()[j] {
            while needle.as_bytes()[i] != needle.as_bytes()[j] &amp;&amp; j &gt;= 1 {
                j = tmpvec[j - 1];
            }
        }
        if needle.as_bytes()[i] == needle.as_bytes()[j] {
            j += 1;
        }
        tmpvec.push(j);
        i += 1;
    }

    let mut next: Vec&lt;i32&gt; = Vec::with_capacity(needle.len());
    next.push(-1);
    for i in 0..tmpvec.len() - 1 {
        next.push(tmpvec[i] as i32);
    }
    next
}

pub fn str_str(haystack: String, needle: String) -&gt; i32 {
    if needle.len() == 0 {
        return 0;
    }
    let next = get_next(needle.borrow());
    let mut i = 0;
    let mut j = 0;
    while i &lt; haystack.len() {
        if haystack.as_bytes()[i] == needle.as_bytes()[j] {
            j += 1;
            if j == needle.len() {
                return (i - j + 1) as i32;
            }
            i += 1;
        } else {
            if j != 0 {
                j = next[j] as usize;
            }else{
                i += 1;
            }
        }

    }
    return -1;
}

fn main() {
    let str1 = String::from(&quot;mississippi&quot;);
    let str2 = String::from(&quot;issip&quot;);
    println!(&quot;{}&quot;, str_str(str1, str2));

}

</code></pre></pre>
<img src="./image-20200701193612961.png" alt="image-20200701193612961" style="zoom:50%;" /><h1><a class="header" href="#leetcode-第19题----a-hrefhttpsleetcode-cncomproblemsremove-nth-node-from-end-of-list删除链表的倒数第n个节点aeasy" id="leetcode-第19题----a-hrefhttpsleetcode-cncomproblemsremove-nth-node-from-end-of-list删除链表的倒数第n个节点aeasy">Leetcode 第19题 -  <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个节点</a>(easy)</a></h1>
<p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h1><a class="header" href="#解题思路-5" id="解题思路-5">解题思路</a></h1>
<p>这道题的难点是怎么找到倒数 第 n个节点,就好像 你如果不把每一颗盒子里面的糖都吃一遍,那么 你就没法确切的知道 有多少颗 酸的多少颗是甜的。 我们要知道 倒数第n个数 那必须要知道 最后一个数,才能相对的确定第 倒数第 n 个数。</p>
<p>那么 一种可行方法是 先遍历一遍链表 计算出链表有多少个值,然后可以确定 最后第 n个数的位置 其中一种方案 是 我们递归调用 然后从后向前回溯,就能找到 这也是 rust 里面相对便于实现的一种方法。</p>
<p>在rust 里面 操作链表 比较麻烦,我们 通常用 take() 来吧当前链表 拿到手,take 会把 当前链表的 替换为为nil 然后我们就能获取链表的所有权了。</p>
<h1><a class="header" href="#递归栈-回溯" id="递归栈-回溯">递归栈 回溯</a></h1>
<p>我们 先递归到底,然后到底之后给定的 n 就可以 减去 1,这样 从底部开始 减,那么 减到 第 n 个就是 0了,然后 我们 直接返回向上返回 它的 next 而不返回当前节点,这样就可以实现删除啦。</p>
<p>要对 n 操作 所以我们单独写一个函数,把 n 改成引用类型。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::borrow::BorrowMut;
impl Solution {
    pub fn remove_nth_from_end(head: Option&lt;Box&lt;ListNode&gt;&gt;, n: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut n = n;
        Solution::remove_nth_from_end_recursion(head,n.borrow_mut())
    }
    pub fn remove_nth_from_end_recursion(head: Option&lt;Box&lt;ListNode&gt;&gt;, n: &amp;mut i32   ) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut linlist: Option&lt;Box&lt;ListNode&gt;&gt;  = head;
        match linlist.take() {
            None =&gt; {None},
            Some(mut x) =&gt; {
            		// 递归栈
                let next = Solution::remove_nth_from_end_recursion(x.next.take(),n);
                //上面 会递归到底 然后我们在这每次-1 来计算倒数n个
                *n -=1;
                println!(&quot;{}&quot;,*n);
                //如果 当前节点是倒数第 n 个,那么 我们 返回这个节点的next 节点 跳过当前节点,相当于删除了当前节点
                if *n == 0 {
                    return next	;
                }else{
                //否则一般情况 把 next 和 当前节点 链接在一起返回
                    x.next = next;
                    return Some(x);
                }
            },

        }

    }

}

</code></pre></pre>
<img src="./image-20200701233310512.png" alt="image-20200701233310512" style="zoom:50%;" />
<h1><a class="header" href="#leetcode-第19题---a-hrefhttpsleetcode-cncomproblemsremove-duplicates-from-sorted-array删除排序数组中的重复项a" id="leetcode-第19题---a-hrefhttpsleetcode-cncomproblemsremove-duplicates-from-sorted-array删除排序数组中的重复项a">Leetcode 第19题 - <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></a></h1>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<blockquote>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
print(nums[i]);
}</p>
</blockquote>
<h1><a class="header" href="#解题思路-6" id="解题思路-6">解题思路</a></h1>
<p>如果普通的方法 我们就,new 一个 新的数组,但是题目 有要求 我们 不能有额外的空间复杂度,那么 我们只能边 遍历 边修改.有了这个想法 我们得思考,那么 要一边 遍历 一边改,那么 首先想到 可以有2根指针,一根在前一根在后修改，</p>
<p>那么 指针 a  =0 指针 b =1。</p>
<p>这让我想到了 一个场景,盗墓者在 墓道里走陷阱,同伴在前 它在后面, 然后让同伴 去踩陷阱 索引 + 1,</p>
<p>然后如果 同伴发现 那个是陷阱,那么 他就直接 不走这一步走到 而是沿着同伴成功的那一阁。</p>
<p>我们 可以类似 把重复的 想象成陷阱,那么 假设 j 是探路的,j 先走一步,如果发现没重复 那么 i 及时跟上.如果重复了 i 先 不走,等j + 1步 继续去探路,不重复了咱继续走,并把下一步改成 j所在那一步的样子。</p>
<img src="./image-20200703111133532.png" alt="image-20200703111133532" style="zoom:50%;" />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn remove_duplicates(nums: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {
    if nums.len() == 0 { return 0;}
    let  mut i =0;
    for j in 1..nums.len(){
      	// 没陷阱,就跟着 j
        if nums[j] != nums[i] {
            i+=1;
            nums[i] = nums[j];
        }
    }
    return (i + 1) as i32;
}
<span class="boring">}
</span></code></pre></pre>
<img src="./image-20200703004202937.png" alt="image-20200703004202937" style="zoom:50%;" /><h1><a class="header" href="#leetcode-第108题---a-hrefhttpsleetcode-cncomproblemsconvert-sorted-array-to-binary-search-tree将有序数组转换为二叉搜索树a" id="leetcode-第108题---a-hrefhttpsleetcode-cncomproblemsconvert-sorted-array-to-binary-search-tree将有序数组转换为二叉搜索树a">Leetcode 第108题 - <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></a></h1>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>  0
 / \
</code></pre>
<p>-3   9
/   /
-10  5</p>
</blockquote>
<h1><a class="header" href="#解题思路-7" id="解题思路-7">解题思路</a></h1>
<p>这道题 我们要注意,给定的是一个有序数组和 高度差 不超过 2,如果 直接采用 普通的平衡二叉树的方式,那么就会变成一个链表,所以 我们采用递归  + 二分法 把 大的放左边 小的放 右边 </p>
<p>举个例子  我们把问题规模缩小来思考,如果一个数组 只有 2个数,我们 把 它 除以 2  然后 把左边一个 小的放在左边,右边放大的。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn sorted_array_to_bst(nums: Vec&lt;i32&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        if nums.is_empty() {
            None
        } else {
            help(&amp;nums, 0, nums.len())
        }
    }
}

fn help(nums: &amp;Vec&lt;i32&gt;, start: usize, end: usize) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
    if start &gt;= end {
        None
    } else {
        let mid = (start + end) / 2;
        let node = Rc::new(RefCell::new(TreeNode::new(nums[mid])));
        node.borrow_mut().left = help(nums, start, mid);
        node.borrow_mut().right = help(nums, mid + 1, end);
        Some(node)
    }

}
<span class="boring">}
</span></code></pre></pre>
<p><img src="./img/image-20200703231300144.png" alt="image-20200703231300144" /></p>
<h1><a class="header" href="#leetcode-第32题-a-hrefhttpsleetcode-cncomproblemslongest-valid-parentheses最长有效括号a" id="leetcode-第32题-a-hrefhttpsleetcode-cncomproblemslongest-valid-parentheses最长有效括号a">Leetcode 第32题 <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">最长有效括号</a></a></h1>
<p>给定一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: &quot;(()&quot;
输出: 2
解释: 最长有效括号子串为 &quot;()&quot;</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: &quot;)()())&quot;
输出: 4
解释: 最长有效括号子串为 &quot;()()&quot;</p>
</blockquote>
<h1><a class="header" href="#解题思" id="解题思">解题思</a></h1>
<p>通过栈的特性。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn longest_valid_parentheses(s: String) -&gt; i32 {
    let mut stack:Vec&lt;i32&gt;=Vec::with_capacity(100);
    let mut carry=-1;
    s.bytes().enumerate().fold(0,|s,(i,x)|
        if x==b'('{
            stack.push(carry);
            carry=i as i32;
            s
        }else if let Some(z)=stack.pop(){
            carry=z;
            s.max(i as i32-z)
        }else{
            carry=i as i32;s
        }
    )
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#leetcode-第70题-a-hrefhttpsleetcode-cncomproblemsclimbing-stairs爬楼梯a" id="leetcode-第70题-a-hrefhttpsleetcode-cncomproblemsclimbing-stairs爬楼梯a">Leetcode 第70题 <a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></a></h1>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>**注意：**给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
</blockquote>
<h1><a class="header" href="#解题思路-8" id="解题思路-8">解题思路</a></h1>
<p>爬楼梯 就是进店的斐波那契数的只是字面上换了换了个皮肤,把 生兔子 换成了 爬楼梯。斐波那契数 在物理学上 和自然里 都有应用。</p>
<p>我们都知道斐波那契函数 是 1 1 2 3 5 8 13</p>
<p>斐波那契 函数 前 2个 定义为 1 和 1 </p>
<p>第三个 开始,则是为前 2个数之和 a[n] = a[n-1] + a[n-2]</p>
<h1><a class="header" href="#递归实现" id="递归实现">递归实现</a></h1>
<p>那么 再回到爬楼梯的问题上来,我们 爬楼梯 </p>
<p>如果要爬 0 步 楼梯 有 1一种选择,那就是不动 我们可以理解为 空集 {}</p>
<p>如果要爬 1步楼梯 我们还是 一种方法 走一步 我们可以理解为 只有一步 {1}</p>
<table><thead><tr><th>爬楼梯</th><th>方式(爬n-1级 + 1级 或 爬 n-2级 + 2 级)</th></tr></thead><tbody>
<tr><td>爬 n = 0 级</td><td>{{}}</td></tr>
<tr><td>爬 n = 1 级</td><td>{{1}}</td></tr>
<tr><td>爬 n = 2 级</td><td>爬1级 + 1级 = {{1} +{1}} = {1,1} | 爬0级 + 2级 = {} + 2 ={2}   =&gt;  {{1,2},{2}}</td></tr>
<tr><td>爬 n = 3 级</td><td>爬2级 + 1级 = {{1,2},{2}} + 1 = {1,2,1},{2,1} | 爬1级 + 2级 = {1} + 2 = {1,2}  =&gt; {{1,2,1},{2,1},{1,2}}</td></tr>
<tr><td>爬 n = 4 级</td><td>爬 3级 + 1级  = {{1,2,1},{2,1},{1,2}} + 1 = {{1,2,1,1},{2,1,1},{1,2,1}}  | 爬2级 + 2级 = {{1,2},{2}} + 2 = {{1,2,2},{2,2}}</td></tr>
<tr><td>爬 n  级</td><td>爬 n -1级 + 1级   | 爬 n -  2 级 + 2级</td></tr>
</tbody></table>
<p>从上面表格 我们可以总结出 这么个公式：<em>f</em>(n*)=<em>f</em>(<em>n</em>−1)+*f(<em>n</em>−2)</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn climb_stairs(n: i32) -&gt; i32 {
    climb_stairs_memo(n)
}

pub fn climb_stairs_memo(n: i32) -&gt; i32 {
		// 爬0步 1种方法
    if n == 0  { return 1;}
    // 爬 1步 一种方法
    if n == 1 {return 1 ;}
    //f(n)=f(n−1)+f(n−2)
    return climb_stairs_memo(n -1) + climb_stairs_memo(n - 2);
}
fn main() {
    println!(&quot;{}&quot;,climb_stairs(20));
}
</code></pre></pre>
<p>要确定 n 就要 确定 n的 前2项,如果 要求n阶台阶 的走法,那么 2^n级别。但是 如下图 每次计算包含重复的计算,</p>
<img src="./img/image-20200705232759694.png" alt="image-20200705232759694" style="zoom:50%;" />
<p>时间复杂度：O(n^2) </p>
<p>空间复杂度：O(1)</p>
<p><img src="./img/image-20200706152052371.png" alt="image-20200706152052371" /></p>
<p>就像上面分析的,由于包含很多重复计算,导致超出了时间复杂度。</p>
<p>那么我们想要 优化的思路是 可以 用空间复杂度换 时间复杂度,我们可以把 所有计算记忆下来,如果遇到相同的计算直接从数组中返回值，这样 就可以大大 减少不必要的重复运算。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn climb_stairs(n: i32) -&gt; i32 {
    //初始化记忆 数组 为 -1
    let mut memory:Vec&lt;i32&gt; =  (0..n+1).map(|x| -1).collect();
    memory[0] = 1;
    memory[1] = 1;
    climb_stairs_memo(n,memory.borrow_mut())
}

pub fn climb_stairs_memo(n: i32,memory:&amp;mut Vec&lt;i32&gt;) -&gt; i32 {
    if memory[n as usize] != -1 {
        return memory[n as usize]
    }
    let res =  climb_stairs_memo(n -1,memory) + climb_stairs_memo(n - 2,memory);
    //保存数组
    memory[n as usize] = res;
    res
}
fn main() {
    println!(&quot;{}&quot;,climb_stairs(20));
}
</code></pre></pre>
<img src="./img/image-20200706155203491.png" alt="image-20200706155203491" style="zoom:50%;" />
<h1><a class="header" href="#动态规划思想" id="动态规划思想">动态规划思想</a></h1>
<p>上面的 递归在改进后,最后我们使用一个数组去记录每个 计算过的值,这就是动态规划的思想了,一个问题 分解成 跟小规模的子问题 找到每个子问题 的最优解 保存起来 合在一起就是 这个问题的最优解,就是动态规划的思想了。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn climb_stairs(n: i32) -&gt; i32 {
    let mut arr = Vec::new();
    arr.push(1);
    arr.push(1);
    for i in 2..(n + 1) as usize{
        arr.push(arr[i-1] + arr[i-2]);
    }
    //返回
    return arr[n as usize];

	}
fn main() {
    println!(&quot;{}&quot;,climb_stairs(20));
}
</code></pre></pre>
<img src="./img/image-20200705233627492.png" alt="image-20200705233627492" style="zoom:50%;" />
<p>我们使用了一个 O(n)  的数组存放了数据,并且 使用了 一次循环,得出：</p>
<p>空间复杂度： O(n)</p>
<p>时间复杂度： O(n)</p>
<h2><a class="header" href="#优化动态规划" id="优化动态规划">优化动态规划</a></h2>
<p>在这提中,我们计算 n 值 需要 n -1 和 n -2 的值,所以完全没必要 使用一个数组,所以可以 直接使用2各变量替代。</p>
<p>将 空间复杂度降到 O(1)</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn climb_stairs(n: i32) -&gt; i32 {
    let mut n_2 = 0;
    let mut n_1 = 1;
    for i in 0..n as usize
    {
        let x = n_2;
        n_2 = n_1;
        n_1 = n_1 + x;
    }
    return n_1;

}
fn main() {
    println!(&quot;{}&quot;,climb_stairs(20));
}
</code></pre></pre>
<img src="./img/image-20200706144310727.png" alt="image-20200706144310727" style="zoom:50%;" />
<h1><a class="header" href="#leetcode-第120题-a-hrefhttpsleetcode-cncomproblemstriangle三角形最小路径和a" id="leetcode-第120题-a-hrefhttpsleetcode-cncomproblemstriangle三角形最小路径和a">Leetcode 第120题 <a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></a></h1>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<p>例如，给定三角形：</p>
<blockquote>
<p>[
[2],
[3,4],
[6,5,7],
[4,1,8,3]
]</p>
</blockquote>
<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p>
<p><strong>说明：</strong></p>
<p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<h1><a class="header" href="#解题思路-9" id="解题思路-9">解题思路</a></h1>
<p>首先 题目说了自上而下,然后只能往相邻的元素走, 相邻 就是 索引 一样 或者 索引 + 1, 所以 它的next 就是它下一层 的 索引和当前一样 或者索引 +1。</p>
<p>理论上 要找到 最小的路径和,我们要对所有可能要找的路径 进行计算然后取最小的。</p>
<h1><a class="header" href="#动态规划-1" id="动态规划-1">动态规划</a></h1>
<p>这题可以用动态规划的思想,一上来如果没有方向的话,我们 可以找一个小的子问题去解决它,也许写着写着 就有灵感了。那么 我们先尝试着看看 怎么找下一个相邻节点。</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn minimum_total(triangle: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {
    let floor =  triangle.len() -1;
		// triangle.len() -1 最后一层没有下一个节点 不需要找
    for i in 0..triangle.len() -1{
        for j  in  0..triangle[i].len(){
            if  j + 1 &lt; triangle[i + 1].len() {
                print!(&quot; | {} next {} {}&quot;,triangle[i][j],triangle[i + 1][j],triangle[i + 1][j +1]);
            }else{
                print!(&quot;{} next {} &quot;,triangle[i][j],triangle[i + 1][j]);
            }

        }
        println!();
    }
    1

}

fn main() {
    let angle:Vec&lt;Vec&lt;i32&gt;&gt; = vec![ vec![2], vec![3,4], vec![6,5,7], vec![4,1,8,3]];
    minimum_total(angle);

}
</code></pre></pre>
<p>我们找到了,每一个数的下一个相邻节点,除了最后一层 没有下一个相邻节点,有了 相邻节点 我们就可以计算 当前 节点 到相邻节点的和了,有了这个基础  我们 只需要 把 每一步 和上一步的 值 相加 就可以得出答案了。</p>
<p>我的思路是 定义一个lastsummary 用来记录 上一层的信息。</p>
<img src="./img/image-20200706200455342.png" alt="image-20200706200455342" style="zoom:50%;" />
<p>如上图,每一个节点 是上一个节点之和, 由于只能往右,所以我们知道每一个节点的上一个节点 必然是 自身的index 或者 index-1 ,那么 我们一开始 使用一个 lastsummary 里面包含一个 0。</p>
<p>那么 第一层 2 + 0 =2 lastsummary =[2]</p>
<p>第二层  3 + 2 = 5 、4 + 2 = 6  lastsummary = [5,6]</p>
<p>我们是通过 当前index 和当前 index -1 索引 的 上一层的 lastsummary,如果 得出2个值,如第三层 10 和 11 ,它们其实所处的位置都是一样的  所以 2者我们取其中最小值,就可以了。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::cmp::{max, min};
pub fn minimum_total(triangle: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {
    if  triangle.len() == 0{ return 0;}
    let  mut sum = vec![0];
    for i in 0..triangle.len(){
        let mut floor = vec![];
        for j  in  0..triangle[i].len(){
            if  j &lt; 1 {
                floor.push(sum[j] + triangle[i][j]);
            }else if( j  == triangle[i].len() -1 ){
                floor.push(sum[j -1] + triangle[i][j]);
            } else {
                floor.push(min(sum[j-1] + triangle[i][j],sum[j] + triangle[i][j]));
            }
        }
        sum = floor;
    }
    *sum.iter().min().unwrap()
}
fn main() {

    let angle:Vec&lt;Vec&lt;i32&gt;&gt; = vec![ vec![-1], vec![2,3], vec![1,-1,-3]];
    println!(&quot;{}&quot;,minimum_total(angle));
}
</code></pre></pre>
<p>算法复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<img src="./img/image-20200706201103414.png" alt="image-20200706201103414" style="zoom:50%;" /><h1><a class="header" href="#leetcode-第198题a-hrefhttpsleetcode-cncomproblemshouse-robber-打家劫舍a" id="leetcode-第198题a-hrefhttpsleetcode-cncomproblemshouse-robber-打家劫舍a">Leetcode 第198题.<a href="https://leetcode-cn.com/problems/house-robber/"> 打家劫舍</a></a></h1>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<h1><a class="header" href="#tag" id="tag">tag</a></h1>
<p>动态规划</p>
<h1><a class="header" href="#解题思路-10" id="解题思路-10">解题思路</a></h1>
<p>这道 题目 和 <a href="./chapter_12.html">Leetcode 第70题 -  [爬楼梯]</a> 类似,根据题目的定义,我们 只能找相邻元素.</p>
<p>你偷 了 第一个房子 那么要偷下一个房子的范围  [3,n-1] </p>
<p>假设 你偷了第二间房子 那么要偷的下一房子 范围为 [4,n-1]</p>
<p>以此类推 你偷了第m间房子 那么要偷的下一间房子的范围为[m+2,n-1],</p>
<p>考虑 当偷到 第m间 最大情况为 下一间 是最后一间</p>
<p>另 m + 2  = n -1</p>
<p>得 m = n -3</p>
<p>所以 当 m 为 n-3 时,小偷要偷的下一间房子为 n -1为最后一间,在这之后 小偷去偷 n -2 n-1 就没有符合条件的下一间要偷的房子了.所以只能偷一间。</p>
<p>值的注意的一点是,在计算范围时 如  [3,n-1]  ,[4,n-1]  把他们做一下交集就会有公共的部分,每次都去重新计算 会花费大量时间,所以我们就要 把 [m,n-1] 区间的结果 记录起来。</p>
<p>所以 可以得出子问题 ：</p>
<p>v(m) =  max{f(m) + v(m+2)}</p>
<p>v(m) 代表第 取第 m 个元素时,再剩下的 m + 2 个 取一个房子取到的最大金额。</p>
<h1><a class="header" href="#-1" id="-1"></a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::borrow::{Borrow, BorrowMut};
use std::cmp::{max, min};
impl Solution {
pub fn rob(nums: Vec&lt;i32&gt;) -&gt; i32 {
    let mut memory:Vec&lt;i32&gt; =  (0..nums.len()).map(|x| -1).collect();
    helper(nums.as_ref(),0,memory.borrow_mut())
}

}
pub fn helper(nums: &amp;Vec&lt;i32&gt;,index:usize,memory: &amp;mut Vec&lt;i32&gt;)-&gt; i32{
    if index &gt;= nums.len(){
        return 0;
    }

    if memory[index] != -1{
        return memory[index]
    }
    let mut res =0;
    for i in index..nums.len(){
        res = max(res ,nums[i] + helper(nums,i + 2,memory));
    }
    memory[index] = res;
    res
}
<span class="boring">}
</span></code></pre></pre>
<img src="./img/image-20200708002230627.png" alt="image-20200708002230627" style="zoom:50%;" /><h1><a class="header" href="#leetcode-第155题-a-hrefhttpsleetcode-cncomproblemsmin-stack-最小栈a" id="leetcode-第155题-a-hrefhttpsleetcode-cncomproblemsmin-stack-最小栈a">Leetcode 第155题 <a href="https://leetcode-cn.com/problems/min-stack/"> 最小栈</a></a></h1>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>输出：
[null,null,null,null,-3,null,0,-2]</p>
<p>解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>
</ul>
<h1><a class="header" href="#解题思路-11" id="解题思路-11">解题思路</a></h1>
<p>这道题目主要考察数据结构,实现起来也很简单 我们定义一个额外的栈 存放最小值,比较下 比辅助栈内元素小的话 就入栈。</p>
<p>入栈 3 
|   |    |   |
|   |    |   |
|<em>3</em>|    |<em>3</em>|
stack  minStack</p>
<p>入栈 5 ， 5 大于 minStack 栈顶，不处理
|   |    |   |
| 5 |    |   |
|<em>3</em>|    |<em>3</em>|
stack  minStack</p>
<p>入栈 2 ，此时右边的 minStack 栈顶就保存了当前最小值 2 
| 2 |    |   |
| 5 |    | 2 |
|<em>3</em>|    |<em>3</em>|
stack  minStack</p>
<p>出栈 2，此时右边的 minStack 栈顶就保存了当前最小值 3
|   |    |   |
| 5 |    |   |
|<em>3</em>|    |<em>3</em>|
stack  minStack</p>
<p>出栈 5，右边 minStack 不处理
|   |    |   |
|   |    |   |
|<em>3</em>|    |<em>3</em>|
stack  minStack</p>
<p>出栈 3
|   |    |   |
|   |    |   |
|_ <em>|    |</em> _|
stack  minStack</p>
<p>这道题可以帮助我们 熟悉如何用 Rust 栈 数据结构我们用Vec 数组来存储栈元素。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct MinStack {
    stack:Vec&lt;i32&gt;,
    minstack:Vec&lt;i32&gt;,

}


/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */
impl MinStack {

    /** initialize your data structure here. */
    fn new() -&gt; Self {
        MinStack {
            stack: vec![],
            minstack: vec![],
        }
    }

    fn push(&amp;mut self, x: i32) {
        self.stack.push(x);
        if self.minstack.len() == 0 ||
            x &lt;= self.get_min(){  self.minstack.push(x)
        }

    }

    fn pop(&amp;mut self) {
        if self.stack[self.stack.len()-1] == self.minstack[self.minstack.len()-1] {
            self.minstack.remove(self.minstack.len()-1);

        }
        self.stack.remove(self.stack.len()-1);

    }

    fn top(&amp;self) -&gt; i32 {

        self.stack[self.stack.len()-1]
    }

    fn get_min(&amp;self) -&gt; i32 {
        if self.minstack.len() ==0 {  return 0;}
        self.minstack[self.minstack.len()-1]
    }
}
</code></pre></pre>
<img src="./img/image-20200708234529054.png" alt="image-20200708234529054" style="zoom:50%;" />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
